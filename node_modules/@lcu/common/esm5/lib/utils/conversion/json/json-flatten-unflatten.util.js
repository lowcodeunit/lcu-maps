import { __read } from "tslib";
import { IsDataTypeUtil } from './../../type/is-data-type.util';
// @dynamic
/**
 * @dynamic is used because this class contains static properties
 */
/**
 * Flatten and Unflatten JSON
 *
 * Original Code Example: http://jsfiddle.net/crl/WSzec/154/
 */
var JSONFlattenUnflatten = /** @class */ (function () {
    function JSONFlattenUnflatten() {
    }
    /**
     * Flatten a standard JSON Object
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.Flatten = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = {}; }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.Flatten(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map[prefix + '[' + itm + ']'] = json[itm];
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                _this.Flatten(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map[(prefix ? prefix + '.' : '') + key] = json[key];
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMap = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                if (Object.entries(json[key]).length === 0) {
                    return;
                }
                _this.FlattenMap(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMapTest = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                if (Object.entries(json[key]).length === 0) {
                    return;
                }
                _this.FlattenMapTest(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMapJSONSchemaItem = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                _this.FlattenMap(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Unflatten an already flatten JSON object
     *
     * @param map object to unflatten
     */
    JSONFlattenUnflatten.Unflatten = function (map) {
        var returnObject = {};
        Object.entries(map).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            var keysRegEx = /(?:\.?([^.[]+))|(\[\d+\])/g;
            var match;
            var oi = returnObject; // ref to returnObject, modified in loop below
            // tslint:disable-next-line:no-conditional-assignment
            while (match = keysRegEx.exec(key)) { // method executes a search for a match in a specified string. Returns a result array,
                var prefix = key[match.index + match[0].length];
                var keyName = match[1];
                if (!prefix) { // nothing more, store value in oi[keyName]
                    oi[keyName] = value;
                }
                else {
                    if (keyName) {
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                    else {
                        keyName = match[2].slice(1, -1);
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                }
                oi = oi[keyName];
            }
        });
        return returnObject;
    };
    /**
     * Unflatten map data
     *
     * @param map map data
     */
    JSONFlattenUnflatten.UnflattenMap = function (map) {
        var returnObject = {};
        map.forEach(function (value, key) {
            var keysRegEx = /(?:\.?([^.[]+))|(\[\d+\])/g;
            var match;
            var oi = returnObject; // ref to returnObject, modified in loop below
            // tslint:disable-next-line:no-conditional-assignment
            while (match = keysRegEx.exec(key)) { // method executes a search for a match in a specified string. Returns a result array,
                var prefix = key[match.index + match[0].length];
                var keyName = match[1];
                if (!prefix) { // nothing more, store value in oi[keyName]
                    oi[keyName] = value;
                }
                else {
                    if (keyName) {
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                    else {
                        keyName = match[2].slice(1, -1);
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                }
                oi = oi[keyName];
            }
        });
        return returnObject;
    };
    return JSONFlattenUnflatten;
}());
export { JSONFlattenUnflatten };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1mbGF0dGVuLXVuZmxhdHRlbi51dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGxjdS9jb21tb24vIiwic291cmNlcyI6WyJsaWIvdXRpbHMvY29udmVyc2lvbi9qc29uL2pzb24tZmxhdHRlbi11bmZsYXR0ZW4udXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBSWhFLFdBQVc7QUFFWDs7R0FFRztBQUVIOzs7O0dBSUc7QUFDSDtJQUFBO0lBdU5DLENBQUM7SUFyTkE7Ozs7Ozs7O09BUUc7SUFDVyw0QkFBTyxHQUFyQixVQUFzQixJQUF1QixFQUFFLEdBQVEsRUFBRSxNQUFXO1FBQXBFLGlCQXNCQztRQXRCOEMsb0JBQUEsRUFBQSxRQUFRO1FBQUUsdUJBQUEsRUFBQSxXQUFXO1FBQ2xFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBRyxFQUFFLEdBQUc7Z0JBQ3BCLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ25ELEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztpQkFDeEQ7cUJBQU07b0JBQ0wsR0FBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDM0M7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sR0FBRyxDQUFDO1NBQ1o7UUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQVk7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LE1BQU0sR0FBVyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzFELElBQUksT0FBTyxHQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFL0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLDJDQUEyQztvQkFDdEQsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztpQkFDdkI7cUJBQU07b0JBQ0gsSUFBSSxPQUFPLEVBQUU7d0JBQ1gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQy9CLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzt5QkFDeEM7cUJBQ0o7eUJBQU07d0JBQ0wsT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ2hDLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUMvQixFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7eUJBQ3hDO3FCQUNGO2lCQUNGO2dCQUNELEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbEI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7SUFDSiwyQkFBQztBQUFELENBQUMsQUF2TkYsSUF1TkUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJc0RhdGFUeXBlVXRpbCB9IGZyb20gJy4vLi4vLi4vdHlwZS9pcy1kYXRhLXR5cGUudXRpbCc7XHJcbmltcG9ydCB7IEpTT05TY2hlbWEgfSBmcm9tICcuLi8uLi8uLi9qc29uLXNjaGVtYSc7XHJcbmltcG9ydCB7IEpTT05TY2hlbWFJdGVtTW9kZWwgfSBmcm9tICcuLi8uLi8uLi9tb2RlbHMvanNvbi9qc29uLXNjaGVtYS1pdGVtLm1vZGVsJztcclxuXHJcbi8vIEBkeW5hbWljXHJcblxyXG4vKipcclxuICogQGR5bmFtaWMgaXMgdXNlZCBiZWNhdXNlIHRoaXMgY2xhc3MgY29udGFpbnMgc3RhdGljIHByb3BlcnRpZXNcclxuICovXHJcblxyXG4vKipcclxuICogRmxhdHRlbiBhbmQgVW5mbGF0dGVuIEpTT05cclxuICpcclxuICogT3JpZ2luYWwgQ29kZSBFeGFtcGxlOiBodHRwOi8vanNmaWRkbGUubmV0L2NybC9XU3plYy8xNTQvXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSlNPTkZsYXR0ZW5VbmZsYXR0ZW4ge1xyXG5cclxuICAvKipcclxuICAgKiBGbGF0dGVuIGEgc3RhbmRhcmQgSlNPTiBPYmplY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHRvIGJlIGZsYXR0ZW5lZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hcCByZWN1cnNpdmUgbWFwIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBwcmVmaXggZG90bm90YXRlZCBwYXRoXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBGbGF0dGVuKGpzb246IEpTT04gfCBKU09OU2NoZW1hLCBtYXAgPSB7fSwgcHJlZml4ID0gJycpOiBvYmplY3Qge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcclxuICAgICAganNvbi5mb3JFYWNoKChpdG0sIGlkeCkgPT4ge1xyXG4gICAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2l0bV0pICYmIGpzb25baXRtXSkge1xyXG4gICAgICAgICAgdGhpcy5GbGF0dGVuKGpzb25baXRtXSwgbWFwLCBwcmVmaXggKyAnWycgKyBpdG0gKyAnXScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtYXBbcHJlZml4ICsgJ1snICsgaXRtICsgJ10nXSA9IGpzb25baXRtXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhqc29uKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgaWYgKElzRGF0YVR5cGVVdGlsLklzT2JqZWN0KGpzb25ba2V5XSkgJiYganNvbltrZXldKSB7XHJcbiAgICAgICAgdGhpcy5GbGF0dGVuKGpzb25ba2V5XSwgbWFwLCAocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsga2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXBbKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleV0gPSBqc29uW2tleV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGbGF0dGVuIEpTT04gaW50byBhIG1hcFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGpzb24gSlNPTiBvYmplY3QgdG8gYmUgZmxhdHRlbmVkXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbWFwIHJlY3Vyc2l2ZSBtYXAgZGF0YVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByZWZpeCBkb3Rub3RhdGVkIHBhdGhcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIEZsYXR0ZW5NYXAoanNvbjogSlNPTiB8IEpTT05TY2hlbWEsIG1hcCA9IG5ldyBNYXAoKSwgcHJlZml4OiBzdHJpbmcgPSAnJyk6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcclxuICAgICAganNvbi5mb3JFYWNoKChpdG0sIGlkeCkgPT4ge1xyXG4gICAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2l0bV0pICYmIGpzb25baXRtXSkge1xyXG4gICAgICAgICAgdGhpcy5GbGF0dGVuTWFwKGpzb25baXRtXSwgbWFwLCBwcmVmaXggKyAnWycgKyBpdG0gKyAnXScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtYXAuc2V0KHByZWZpeCArICdbJyArIGl0bSArICddJywganNvbltpdG1dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhqc29uKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcclxuICAgICAgaWYgKElzRGF0YVR5cGVVdGlsLklzT2JqZWN0KGpzb25ba2V5XSkgJiYganNvbltrZXldKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGpzb25ba2V5XSkubGVuZ3RoID09PSAwKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMuRmxhdHRlbk1hcChqc29uW2tleV0sIG1hcCwgKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICBtYXAuc2V0KChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrZXksIGpzb25ba2V5XSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGbGF0dGVuIEpTT04gaW50byBhIG1hcFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGpzb24gSlNPTiBvYmplY3QgdG8gYmUgZmxhdHRlbmVkXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbWFwIHJlY3Vyc2l2ZSBtYXAgZGF0YVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHByZWZpeCBkb3Rub3RhdGVkIHBhdGhcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIEZsYXR0ZW5NYXBUZXN0KGpzb246IEpTT04gfCBKU09OU2NoZW1hLCBtYXAgPSBuZXcgTWFwKCksIHByZWZpeDogc3RyaW5nID0gJycpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgIGpzb24uZm9yRWFjaCgoaXRtLCBpZHgpID0+IHtcclxuICAgICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltpdG1dKSAmJiBqc29uW2l0bV0pIHtcclxuICAgICAgICAgIHRoaXMuRmxhdHRlbk1hcChqc29uW2l0bV0sIG1hcCwgcHJlZml4ICsgJ1snICsgaXRtICsgJ10nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWFwLnNldChwcmVmaXggKyAnWycgKyBpdG0gKyAnXScsIGpzb25baXRtXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXMoanNvbikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2tleV0pICYmIGpzb25ba2V5XSkge1xyXG4gICAgICAgIGlmIChPYmplY3QuZW50cmllcyhqc29uW2tleV0pLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLkZsYXR0ZW5NYXBUZXN0KGpzb25ba2V5XSwgbWFwLCAocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsga2V5KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgbWFwLnNldCgocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsga2V5LCBqc29uW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmxhdHRlbiBKU09OIGludG8gYSBtYXBcclxuICAgKlxyXG4gICAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHRvIGJlIGZsYXR0ZW5lZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hcCByZWN1cnNpdmUgbWFwIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBwcmVmaXggZG90bm90YXRlZCBwYXRoXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBGbGF0dGVuTWFwSlNPTlNjaGVtYUl0ZW0oXHJcbiAgICBqc29uOiBKU09OIHwgSlNPTlNjaGVtYSwgbWFwID0gbmV3IE1hcCgpLCBwcmVmaXg6IHN0cmluZyA9ICcnKTogTWFwPHN0cmluZywgSlNPTlNjaGVtYUl0ZW1Nb2RlbD4ge1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgIGpzb24uZm9yRWFjaCgoaXRtLCBpZHgpID0+IHtcclxuICAgICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltpdG1dKSAmJiBqc29uW2l0bV0pIHtcclxuICAgICAgICAgIHRoaXMuRmxhdHRlbk1hcChqc29uW2l0bV0sIG1hcCwgcHJlZml4ICsgJ1snICsgaXRtICsgJ10nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWFwLnNldChwcmVmaXggKyAnWycgKyBpdG0gKyAnXScsIGpzb25baXRtXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXMoanNvbikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2tleV0pICYmIGpzb25ba2V5XSkge1xyXG4gICAgICAgIHRoaXMuRmxhdHRlbk1hcChqc29uW2tleV0sIG1hcCwgKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICBtYXAuc2V0KChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrZXksIGpzb25ba2V5XSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBtYXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbmZsYXR0ZW4gYW4gYWxyZWFkeSBmbGF0dGVuIEpTT04gb2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gbWFwIG9iamVjdCB0byB1bmZsYXR0ZW5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIFVuZmxhdHRlbihtYXA6IG9iamVjdCk6IG9iamVjdCB7XHJcbiAgICBjb25zdCByZXR1cm5PYmplY3Q6IG9iamVjdCA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5lbnRyaWVzKG1hcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGNvbnN0IGtleXNSZWdFeDogUmVnRXhwID0gLyg/OlxcLj8oW14uW10rKSl8KFxcW1xcZCtcXF0pL2c7XHJcbiAgICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcclxuICAgICAgbGV0IG9pOiBvYmplY3QgPSByZXR1cm5PYmplY3Q7IC8vIHJlZiB0byByZXR1cm5PYmplY3QsIG1vZGlmaWVkIGluIGxvb3AgYmVsb3dcclxuXHJcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XHJcbiAgICAgIHdoaWxlIChtYXRjaCA9IGtleXNSZWdFeC5leGVjKGtleSkpIHsgLy8gbWV0aG9kIGV4ZWN1dGVzIGEgc2VhcmNoIGZvciBhIG1hdGNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBhIHJlc3VsdCBhcnJheSxcclxuICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IGtleVttYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aF07XHJcbiAgICAgICAgbGV0IGtleU5hbWU6IHN0cmluZyA9IG1hdGNoWzFdO1xyXG5cclxuICAgICAgICBpZiAoIXByZWZpeCkgeyAvLyBub3RoaW5nIG1vcmUsIHN0b3JlIHZhbHVlIGluIG9pW2tleU5hbWVdXHJcbiAgICAgICAgICBvaVtrZXlOYW1lXSA9IHZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGtleU5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFvaS5oYXNPd25Qcm9wZXJ0eShrZXlOYW1lKSkge1xyXG4gICAgICAgICAgICAgIG9pW2tleU5hbWVdID0gcHJlZml4ID09PSAnWycgPyBbXSA6IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGtleU5hbWUgPSBtYXRjaFsyXS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICBpZiAoIW9pLmhhc093blByb3BlcnR5KGtleU5hbWUpKSB7XHJcbiAgICAgICAgICAgIG9pW2tleU5hbWVdID0gcHJlZml4ID09PSAnWycgPyBbXSA6IHt9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAgIG9pID0gb2lba2V5TmFtZV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgICByZXR1cm4gcmV0dXJuT2JqZWN0O1xyXG4gfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5mbGF0dGVuIG1hcCBkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hcCBtYXAgZGF0YVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFVuZmxhdHRlbk1hcChtYXA6IGFueSk6IG9iamVjdCB7XHJcblxyXG4gICAgICBjb25zdCByZXR1cm5PYmplY3Q6IG9iamVjdCA9IHt9O1xyXG5cclxuICAgICAgbWFwLmZvckVhY2goKHZhbHVlOiBzdHJpbmcsIGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBrZXlzUmVnRXg6IFJlZ0V4cCA9IC8oPzpcXC4/KFteLltdKykpfChcXFtcXGQrXFxdKS9nO1xyXG4gICAgICAgICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xyXG4gICAgICAgICAgbGV0IG9pOiBvYmplY3QgPSByZXR1cm5PYmplY3Q7IC8vIHJlZiB0byByZXR1cm5PYmplY3QsIG1vZGlmaWVkIGluIGxvb3AgYmVsb3dcclxuXHJcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxyXG4gICAgICAgICAgd2hpbGUgKG1hdGNoID0ga2V5c1JlZ0V4LmV4ZWMoa2V5KSkgeyAvLyBtZXRob2QgZXhlY3V0ZXMgYSBzZWFyY2ggZm9yIGEgbWF0Y2ggaW4gYSBzcGVjaWZpZWQgc3RyaW5nLiBSZXR1cm5zIGEgcmVzdWx0IGFycmF5LFxyXG5cclxuICAgICAgICAgIGNvbnN0IHByZWZpeDogc3RyaW5nID0ga2V5W21hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXTtcclxuICAgICAgICAgIGxldCBrZXlOYW1lOiBzdHJpbmcgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgICBpZiAoIXByZWZpeCkgeyAvLyBub3RoaW5nIG1vcmUsIHN0b3JlIHZhbHVlIGluIG9pW2tleU5hbWVdXHJcbiAgICAgICAgICAgICAgb2lba2V5TmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKGtleU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb2kuaGFzT3duUHJvcGVydHkoa2V5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgb2lba2V5TmFtZV0gPSBwcmVmaXggPT09ICdbJyA/IFtdIDoge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAga2V5TmFtZSA9IG1hdGNoWzJdLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICBpZiAoIW9pLmhhc093blByb3BlcnR5KGtleU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvaVtrZXlOYW1lXSA9IHByZWZpeCA9PT0gJ1snID8gW10gOiB7fTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG9pID0gb2lba2V5TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJldHVybk9iamVjdDtcclxuICAgIH1cclxuIH1cclxuIl19