import { __read } from "tslib";
import { IsDataTypeUtil } from './../../type/is-data-type.util';
// @dynamic
/**
 * @dynamic is used because this class contains static properties
 */
/**
 * Flatten and Unflatten JSON
 *
 * Original Code Example: http://jsfiddle.net/crl/WSzec/154/
 */
var JSONFlattenUnflatten = /** @class */ (function () {
    function JSONFlattenUnflatten() {
    }
    /**
     * Flatten a standard JSON Object
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.Flatten = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = {}; }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.Flatten(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map[prefix + '[' + itm + ']'] = json[itm];
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                _this.Flatten(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map[(prefix ? prefix + '.' : '') + key] = json[key];
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMap = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                if (Object.entries(json[key]).length === 0) {
                    return;
                }
                _this.FlattenMap(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMapTest = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                if (Object.entries(json[key]).length === 0) {
                    return;
                }
                _this.FlattenMapTest(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Flatten JSON into a map
     *
     * @param json JSON object to be flattened
     *
     * @param map recursive map data
     *
     * @param prefix dotnotated path
     */
    JSONFlattenUnflatten.FlattenMapJSONSchemaItem = function (json, map, prefix) {
        var _this = this;
        if (map === void 0) { map = new Map(); }
        if (prefix === void 0) { prefix = ''; }
        if (Array.isArray(json)) {
            json.forEach(function (itm, idx) {
                if (IsDataTypeUtil.IsObject(json[itm]) && json[itm]) {
                    _this.FlattenMap(json[itm], map, prefix + '[' + itm + ']');
                }
                else {
                    map.set(prefix + '[' + itm + ']', json[itm]);
                }
            });
            return map;
        }
        Object.entries(json).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (IsDataTypeUtil.IsObject(json[key]) && json[key]) {
                _this.FlattenMap(json[key], map, (prefix ? prefix + '.' : '') + key);
            }
            else {
                map.set((prefix ? prefix + '.' : '') + key, json[key]);
            }
        });
        return map;
    };
    /**
     * Unflatten an already flatten JSON object
     *
     * @param map object to unflatten
     */
    JSONFlattenUnflatten.Unflatten = function (map) {
        var returnObject = {};
        Object.entries(map).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            var keysRegEx = /(?:\.?([^.[]+))|(\[\d+\])/g;
            var match;
            var oi = returnObject; // ref to returnObject, modified in loop below
            // tslint:disable-next-line:no-conditional-assignment
            while (match = keysRegEx.exec(key)) { // method executes a search for a match in a specified string. Returns a result array,
                var prefix = key[match.index + match[0].length];
                var keyName = match[1];
                if (!prefix) { // nothing more, store value in oi[keyName]
                    oi[keyName] = value;
                }
                else {
                    if (keyName) {
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                    else {
                        keyName = match[2].slice(1, -1);
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                }
                oi = oi[keyName];
            }
        });
        return returnObject;
    };
    /**
     * Unflatten map data
     *
     * @param map map data
     */
    JSONFlattenUnflatten.UnflattenMap = function (map) {
        var returnObject = {};
        map.forEach(function (value, key) {
            var keysRegEx = /(?:\.?([^.[]+))|(\[\d+\])/g;
            var match;
            var oi = returnObject; // ref to returnObject, modified in loop below
            // tslint:disable-next-line:no-conditional-assignment
            while (match = keysRegEx.exec(key)) { // method executes a search for a match in a specified string. Returns a result array,
                var prefix = key[match.index + match[0].length];
                var keyName = match[1];
                if (!prefix) { // nothing more, store value in oi[keyName]
                    oi[keyName] = value;
                }
                else {
                    if (keyName) {
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                    else {
                        keyName = match[2].slice(1, -1);
                        if (!oi.hasOwnProperty(keyName)) {
                            oi[keyName] = prefix === '[' ? [] : {};
                        }
                    }
                }
                oi = oi[keyName];
            }
        });
        return returnObject;
    };
    return JSONFlattenUnflatten;
}());
export { JSONFlattenUnflatten };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNvbi1mbGF0dGVuLXVuZmxhdHRlbi51dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGxjdS9jb21tb24vIiwic291cmNlcyI6WyJsaWIvdXRpbHMvY29udmVyc2lvbi9qc29uL2pzb24tZmxhdHRlbi11bmZsYXR0ZW4udXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBSWhFLFdBQVc7QUFFWDs7R0FFRztBQUVIOzs7O0dBSUc7QUFDSDtJQUFBO0lBdU5DLENBQUM7SUFyTkE7Ozs7Ozs7O09BUUc7SUFDVyw0QkFBTyxHQUFyQixVQUFzQixJQUF1QixFQUFFLEdBQVEsRUFBRSxNQUFXO1FBQXBFLGlCQXNCQztRQXRCOEMsb0JBQUEsRUFBQSxRQUFRO1FBQUUsdUJBQUEsRUFBQSxXQUFXO1FBQ2xFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBRyxFQUFFLEdBQUc7Z0JBQ3BCLElBQUksY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7b0JBQ25ELEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztpQkFDeEQ7cUJBQU07b0JBQ0wsR0FBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDM0M7WUFDSCxDQUFDLENBQUMsQ0FBQztZQUVILE9BQU8sR0FBRyxDQUFDO1NBQ1o7UUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQVk7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ICcuLy4uLy4uL3R5cGUvaXMtZGF0YS10eXBlLnV0aWwnO1xyXG5pbXBvcnQgeyBKU09OU2NoZW1hIH0gZnJvbSAnLi4vLi4vLi4vanNvbi1zY2hlbWEnO1xyXG5pbXBvcnQgeyBKU09OU2NoZW1hSXRlbU1vZGVsIH0gZnJvbSAnLi4vLi4vLi4vbW9kZWxzL2pzb24vanNvbi1zY2hlbWEtaXRlbS5tb2RlbCc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5cclxuLyoqXHJcbiAqIEBkeW5hbWljIGlzIHVzZWQgYmVjYXVzZSB0aGlzIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZsYXR0ZW4gYW5kIFVuZmxhdHRlbiBKU09OXHJcbiAqXHJcbiAqIE9yaWdpbmFsIENvZGUgRXhhbXBsZTogaHR0cDovL2pzZmlkZGxlLm5ldC9jcmwvV1N6ZWMvMTU0L1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEpTT05GbGF0dGVuVW5mbGF0dGVuIHtcclxuXHJcbiAgLyoqXHJcbiAgICogRmxhdHRlbiBhIHN0YW5kYXJkIEpTT04gT2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ganNvbiBKU09OIG9iamVjdCB0byBiZSBmbGF0dGVuZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBtYXAgcmVjdXJzaXZlIG1hcCBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcHJlZml4IGRvdG5vdGF0ZWQgcGF0aFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgRmxhdHRlbihqc29uOiBKU09OIHwgSlNPTlNjaGVtYSwgbWFwID0ge30sIHByZWZpeCA9ICcnKTogb2JqZWN0IHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgIGpzb24uZm9yRWFjaCgoaXRtLCBpZHgpID0+IHtcclxuICAgICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltpdG1dKSAmJiBqc29uW2l0bV0pIHtcclxuICAgICAgICAgIHRoaXMuRmxhdHRlbihqc29uW2l0bV0sIG1hcCwgcHJlZml4ICsgJ1snICsgaXRtICsgJ10nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWFwW3ByZWZpeCArICdbJyArIGl0bSArICddJ10gPSBqc29uW2l0bV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXMoanNvbikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2tleV0pICYmIGpzb25ba2V5XSkge1xyXG4gICAgICAgIHRoaXMuRmxhdHRlbihqc29uW2tleV0sIG1hcCwgKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWFwWyhwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrZXldID0ganNvbltrZXldO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmxhdHRlbiBKU09OIGludG8gYSBtYXBcclxuICAgKlxyXG4gICAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHRvIGJlIGZsYXR0ZW5lZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hcCByZWN1cnNpdmUgbWFwIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBwcmVmaXggZG90bm90YXRlZCBwYXRoXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBGbGF0dGVuTWFwKGpzb246IEpTT04gfCBKU09OU2NoZW1hLCBtYXAgPSBuZXcgTWFwKCksIHByZWZpeDogc3RyaW5nID0gJycpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgIGpzb24uZm9yRWFjaCgoaXRtLCBpZHgpID0+IHtcclxuICAgICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltpdG1dKSAmJiBqc29uW2l0bV0pIHtcclxuICAgICAgICAgIHRoaXMuRmxhdHRlbk1hcChqc29uW2l0bV0sIG1hcCwgcHJlZml4ICsgJ1snICsgaXRtICsgJ10nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWFwLnNldChwcmVmaXggKyAnWycgKyBpdG0gKyAnXScsIGpzb25baXRtXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmVudHJpZXMoanNvbikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmIChJc0RhdGFUeXBlVXRpbC5Jc09iamVjdChqc29uW2tleV0pICYmIGpzb25ba2V5XSkge1xyXG4gICAgICAgIGlmIChPYmplY3QuZW50cmllcyhqc29uW2tleV0pLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLkZsYXR0ZW5NYXAoanNvbltrZXldLCBtYXAsIChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrZXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgbWFwLnNldCgocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsga2V5LCBqc29uW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmxhdHRlbiBKU09OIGludG8gYSBtYXBcclxuICAgKlxyXG4gICAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHRvIGJlIGZsYXR0ZW5lZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hcCByZWN1cnNpdmUgbWFwIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBwcmVmaXggZG90bm90YXRlZCBwYXRoXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBGbGF0dGVuTWFwVGVzdChqc29uOiBKU09OIHwgSlNPTlNjaGVtYSwgbWFwID0gbmV3IE1hcCgpLCBwcmVmaXg6IHN0cmluZyA9ICcnKTogTWFwPHN0cmluZywgc3RyaW5nPiB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xyXG4gICAgICBqc29uLmZvckVhY2goKGl0bSwgaWR4KSA9PiB7XHJcbiAgICAgICAgaWYgKElzRGF0YVR5cGVVdGlsLklzT2JqZWN0KGpzb25baXRtXSkgJiYganNvbltpdG1dKSB7XHJcbiAgICAgICAgICB0aGlzLkZsYXR0ZW5NYXAoanNvbltpdG1dLCBtYXAsIHByZWZpeCArICdbJyArIGl0bSArICddJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1hcC5zZXQocHJlZml4ICsgJ1snICsgaXRtICsgJ10nLCBqc29uW2l0bV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5lbnRyaWVzKGpzb24pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltrZXldKSAmJiBqc29uW2tleV0pIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmVudHJpZXMoanNvbltrZXldKS5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgdGhpcy5GbGF0dGVuTWFwVGVzdChqc29uW2tleV0sIG1hcCwgKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgIG1hcC5zZXQoKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIGtleSwganNvbltrZXldKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG1hcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZsYXR0ZW4gSlNPTiBpbnRvIGEgbWFwXHJcbiAgICpcclxuICAgKiBAcGFyYW0ganNvbiBKU09OIG9iamVjdCB0byBiZSBmbGF0dGVuZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBtYXAgcmVjdXJzaXZlIG1hcCBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gcHJlZml4IGRvdG5vdGF0ZWQgcGF0aFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgRmxhdHRlbk1hcEpTT05TY2hlbWFJdGVtKFxyXG4gICAganNvbjogSlNPTiB8IEpTT05TY2hlbWEsIG1hcCA9IG5ldyBNYXAoKSwgcHJlZml4OiBzdHJpbmcgPSAnJyk6IE1hcDxzdHJpbmcsIEpTT05TY2hlbWFJdGVtTW9kZWw+IHtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xyXG4gICAgICBqc29uLmZvckVhY2goKGl0bSwgaWR4KSA9PiB7XHJcbiAgICAgICAgaWYgKElzRGF0YVR5cGVVdGlsLklzT2JqZWN0KGpzb25baXRtXSkgJiYganNvbltpdG1dKSB7XHJcbiAgICAgICAgICB0aGlzLkZsYXR0ZW5NYXAoanNvbltpdG1dLCBtYXAsIHByZWZpeCArICdbJyArIGl0bSArICddJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1hcC5zZXQocHJlZml4ICsgJ1snICsgaXRtICsgJ10nLCBqc29uW2l0bV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5lbnRyaWVzKGpzb24pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICBpZiAoSXNEYXRhVHlwZVV0aWwuSXNPYmplY3QoanNvbltrZXldKSAmJiBqc29uW2tleV0pIHtcclxuICAgICAgICB0aGlzLkZsYXR0ZW5NYXAoanNvbltrZXldLCBtYXAsIChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBrZXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgbWFwLnNldCgocHJlZml4ID8gcHJlZml4ICsgJy4nIDogJycpICsga2V5LCBqc29uW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbWFwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW5mbGF0dGVuIGFuIGFscmVhZHkgZmxhdHRlbiBKU09OIG9iamVjdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIG1hcCBvYmplY3QgdG8gdW5mbGF0dGVuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBVbmZsYXR0ZW4obWFwOiBvYmplY3QpOiBvYmplY3Qge1xyXG4gICAgY29uc3QgcmV0dXJuT2JqZWN0OiBvYmplY3QgPSB7fTtcclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICBjb25zdCBrZXlzUmVnRXg6IFJlZ0V4cCA9IC8oPzpcXC4/KFteLltdKykpfChcXFtcXGQrXFxdKS9nO1xyXG4gICAgICBsZXQgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XHJcbiAgICAgIGxldCBvaTogb2JqZWN0ID0gcmV0dXJuT2JqZWN0OyAvLyByZWYgdG8gcmV0dXJuT2JqZWN0LCBtb2RpZmllZCBpbiBsb29wIGJlbG93XHJcblxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uZGl0aW9uYWwtYXNzaWdubWVudFxyXG4gICAgICB3aGlsZSAobWF0Y2ggPSBrZXlzUmVnRXguZXhlYyhrZXkpKSB7IC8vIG1ldGhvZCBleGVjdXRlcyBhIHNlYXJjaCBmb3IgYSBtYXRjaCBpbiBhIHNwZWNpZmllZCBzdHJpbmcuIFJldHVybnMgYSByZXN1bHQgYXJyYXksXHJcbiAgICAgICAgY29uc3QgcHJlZml4OiBzdHJpbmcgPSBrZXlbbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhdO1xyXG4gICAgICAgIGxldCBrZXlOYW1lOiBzdHJpbmcgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgaWYgKCFwcmVmaXgpIHsgLy8gbm90aGluZyBtb3JlLCBzdG9yZSB2YWx1ZSBpbiBvaVtrZXlOYW1lXVxyXG4gICAgICAgICAgb2lba2V5TmFtZV0gPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChrZXlOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghb2kuaGFzT3duUHJvcGVydHkoa2V5TmFtZSkpIHtcclxuICAgICAgICAgICAgICBvaVtrZXlOYW1lXSA9IHByZWZpeCA9PT0gJ1snID8gW10gOiB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBrZXlOYW1lID0gbWF0Y2hbMl0uc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgICAgaWYgKCFvaS5oYXNPd25Qcm9wZXJ0eShrZXlOYW1lKSkge1xyXG4gICAgICAgICAgICBvaVtrZXlOYW1lXSA9IHByZWZpeCA9PT0gJ1snID8gW10gOiB7fTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgICBvaSA9IG9pW2tleU5hbWVdO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gICAgcmV0dXJuIHJldHVybk9iamVjdDtcclxuIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuZmxhdHRlbiBtYXAgZGF0YVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXAgbWFwIGRhdGFcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBVbmZsYXR0ZW5NYXAobWFwOiBhbnkpOiBvYmplY3Qge1xyXG5cclxuICAgICAgY29uc3QgcmV0dXJuT2JqZWN0OiBvYmplY3QgPSB7fTtcclxuXHJcbiAgICAgIG1hcC5mb3JFYWNoKCh2YWx1ZTogc3RyaW5nLCBrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgY29uc3Qga2V5c1JlZ0V4OiBSZWdFeHAgPSAvKD86XFwuPyhbXi5bXSspKXwoXFxbXFxkK1xcXSkvZztcclxuICAgICAgICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcclxuICAgICAgICAgIGxldCBvaTogb2JqZWN0ID0gcmV0dXJuT2JqZWN0OyAvLyByZWYgdG8gcmV0dXJuT2JqZWN0LCBtb2RpZmllZCBpbiBsb29wIGJlbG93XHJcblxyXG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcclxuICAgICAgICAgIHdoaWxlIChtYXRjaCA9IGtleXNSZWdFeC5leGVjKGtleSkpIHsgLy8gbWV0aG9kIGV4ZWN1dGVzIGEgc2VhcmNoIGZvciBhIG1hdGNoIGluIGEgc3BlY2lmaWVkIHN0cmluZy4gUmV0dXJucyBhIHJlc3VsdCBhcnJheSxcclxuXHJcbiAgICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IGtleVttYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aF07XHJcbiAgICAgICAgICBsZXQga2V5TmFtZTogc3RyaW5nID0gbWF0Y2hbMV07XHJcblxyXG4gICAgICAgICAgaWYgKCFwcmVmaXgpIHsgLy8gbm90aGluZyBtb3JlLCBzdG9yZSB2YWx1ZSBpbiBvaVtrZXlOYW1lXVxyXG4gICAgICAgICAgICAgIG9pW2tleU5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChrZXlOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9pLmhhc093blByb3BlcnR5KGtleU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgIG9pW2tleU5hbWVdID0gcHJlZml4ID09PSAnWycgPyBbXSA6IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGtleU5hbWUgPSBtYXRjaFsyXS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgaWYgKCFvaS5oYXNPd25Qcm9wZXJ0eShrZXlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgb2lba2V5TmFtZV0gPSBwcmVmaXggPT09ICdbJyA/IFtdIDoge307XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBvaSA9IG9pW2tleU5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXR1cm5PYmplY3Q7XHJcbiAgICB9XHJcbiB9XHJcbiJdfQ==