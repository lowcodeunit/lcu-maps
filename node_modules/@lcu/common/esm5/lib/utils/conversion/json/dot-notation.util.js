import { __assign, __read, __spread } from "tslib";
// @dynamic
/**
 * @dynamic is used because this class contains static properties
 */
var DotNotationUtil = /** @class */ (function () {
    function DotNotationUtil() {
    }
    /**
     * Using dot notation, iterate the object and change the key's value
     *
     * @param obj object to test
     *
     * @param propertyPath Dot notation path
     *
     * @param newVal Changed value
     */
    DotNotationUtil.SetValue = function (obj, propertyPath, newVal) {
        /**
         * split propertyPath string into an array of strings and iterate each itm with reduce
         *
         * @param acc(accumulator) returned object to iterate
         *
         * @param curr(current value) current element being processed in the array
         *
         * @param idx index position of the current element being processed in the array
         *
         * @param arr array we created with the split function above
         *
         */
        return propertyPath.split('.').reduce(function (acc, curr, idx, arr) {
            if (idx === (arr.length - 1) && acc) {
                acc[curr] = newVal;
            }
            // return a new accumulator to the reduce callback(starts the loop with the next curr value)
            return acc ? acc[curr] : null;
            // inital value to use as the first argument(this is the item to start the iteration with)
        }, obj);
    };
    /**
     * Using dot notation, iterate the object and return the key's value
     *
     * @param obj object to test
     *
     * @param pathArr array of names used to drill into objects
     */
    DotNotationUtil.GetValue = function (obj, propertyPath) {
        /**
         * split propertyPath string into an array of strings and iterate each itm with reduce
         *
         * @param acc(accumulator) returned object to iterate
         *
         * @param curr(current value) current element being processed in the array
         *
         * @param idx index position of the current element being processed in the array
         *
         * @param arr array we created with the split function above
         *
         */
        return propertyPath.split('.').reduce(function (acc, curr, idx, arr) {
            if (idx === (arr.length - 1) && acc) {
                return acc[curr];
            }
            // return a new accumulator to the reduce callback(starts the loop with the next curr value)
            return acc ? acc[curr] : null;
            // inital value to use as the first argument(this is the item to start the iteration with)
        }, obj);
    };
    DotNotationUtil.SetKeyValue = function (json, propertyPath, oldKey, newKey, objToChange) {
        var _this = this;
        // for top level properties
        if (propertyPath.split('.').length === 1) {
            return Object.keys(json).reduce(function (acc, curr, idx, arr) {
                var _a, _b;
                return curr === oldKey ? (__assign(__assign({}, acc), (_a = {}, _a[newKey] = json[oldKey], _a))) : (__assign(__assign({}, acc), (_b = {}, _b[curr] = json[curr], _b)));
            }, {});
        }
        // for nested properties
        if (propertyPath.split('.').length > 1) {
            return propertyPath.split('.').reduce(function (acc, curr, idx, arr) {
                var _a;
                if (idx === (arr.length - 1) && acc) {
                    var idxPos = arr.indexOf(objToChange);
                    var idxPosArr = __spread(arr.splice(0, idxPos + 1));
                    DotNotationUtil.SetValue(json, idxPosArr.join('.'), _this.RenameKeys((_a = {}, _a[oldKey] = newKey, _a), acc));
                    return json;
                    // return {
                    //   ...schema, [objToChange]: this.renameKeys({[oldKey]: newKey}, acc)
                    // };
                }
                return acc ? acc[curr] : null; // if acc, then start additional iterations with acc[curr]
            }, json); // first item to start the loop
        }
    };
    /**
     * Rename property keys
     */
    DotNotationUtil.RenameKeys = function (keysMap, obj) {
        return Object
            .keys(obj)
            .reduce(function (acc, key) {
            var _a;
            var renamedObject = (_a = {},
                _a[keysMap[key] || key] = obj[key],
                _a);
            return __assign(__assign({}, acc), renamedObject);
        }, {});
    };
    return DotNotationUtil;
}());
export { DotNotationUtil };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90LW5vdGF0aW9uLnV0aWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbGN1L2NvbW1vbi8iLCJzb3VyY2VzIjpbImxpYi91dGlscy9jb252ZXJzaW9uL2pzb24vZG90LW5vdGF0aW9uLnV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLFdBQVc7QUFFWDs7R0FFRztBQUVIO0lBQUE7SUE2R0EsQ0FBQztJQTNHRzs7Ozs7Ozs7T0FRRztJQUNXLHdCQUFRLEdBQXRCLFVBQXVCLEdBQWtCLEVBQUUsWUFBb0IsRUFBRSxNQUFvQztRQUNqRzs7Ozs7Ozs7Ozs7V0FXRztRQUNILE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUUsVUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHO1lBQ3pELElBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUc7Z0JBQ3JDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUM7YUFDcEI7WUFDRCw0RkFBNEY7WUFDNUYsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBRWhDLDBGQUEwRjtRQUM1RixDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ1csd0JBQVEsR0FBdEIsVUFBdUIsR0FBa0IsRUFBRSxZQUFvQjtRQUMzRDs7Ozs7Ozs7Ozs7V0FXRztRQUNMLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUUsVUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHO1lBQ3pELElBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUc7Z0JBQ3JDLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2xCO1lBQ0QsNEZBQTRGO1lBQzVGLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUVoQywwRkFBMEY7UUFDNUYsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUNhLDJCQUFXLEdBQXpCLFVBQTBCLElBQXVCLEVBQUUsWUFBb0IsRUFBRSxNQUFjLEVBQUUsTUFBYyxFQUFFLFdBQW1CO1FBQTVILGlCQTBCQztRQXhCQywyQkFBMkI7UUFDM0IsSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDeEMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBRSxVQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUc7O2dCQUNuRCxPQUFBLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLHVCQUFNLEdBQUcsZ0JBQUcsTUFBTSxJQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBRyxDQUFDLENBQUMsQ0FBQyx1QkFBSyxHQUFHLGdCQUFHLElBQUksSUFBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQUU7WUFBdkYsQ0FBdUYsRUFBRSxFQUFFLENBQUUsQ0FBQztTQUNqRztRQUVELHdCQUF3QjtRQUN4QixJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN0QyxPQUFPLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFFLFVBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRzs7Z0JBQ3ZELElBQUssR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEVBQUc7b0JBRXJDLElBQU0sTUFBTSxHQUFXLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ2hELElBQU0sU0FBUyxZQUF1QixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUUsQ0FBQztvQkFFbEUsZUFBZSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFJLENBQUMsVUFBVSxXQUFFLEdBQUMsTUFBTSxJQUFHLE1BQU0sT0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUU5RixPQUFPLElBQUksQ0FBQztvQkFDWixXQUFXO29CQUNYLHVFQUF1RTtvQkFDdkUsS0FBSztpQkFDTjtnQkFDRCxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQywwREFBMEQ7WUFDN0YsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsK0JBQStCO1NBQzFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ1csMEJBQVUsR0FBeEIsVUFBeUIsT0FBZSxFQUFFLEdBQWtCO1FBQzFELE9BQU8sTUFBTTthQUNKLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDVCxNQUFNLENBQUMsVUFBQyxHQUFHLEVBQUUsR0FBRzs7WUFDZixJQUFNLGFBQWE7Z0JBQ2pCLEdBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBRyxHQUFHLENBQUMsR0FBRyxDQUFDO21CQUNoQyxDQUFDO1lBQ0YsNkJBQ0ssR0FBRyxHQUNILGFBQWEsRUFDaEI7UUFDSixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDakIsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FBQyxBQTdHRCxJQTZHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEpTT05TY2hlbWEgfSBmcm9tICcuLy4uLy4uLy4uL2pzb24tc2NoZW1hJztcclxuLy8gQGR5bmFtaWNcclxuXHJcbi8qKlxyXG4gKiBAZHluYW1pYyBpcyB1c2VkIGJlY2F1c2UgdGhpcyBjbGFzcyBjb250YWlucyBzdGF0aWMgcHJvcGVydGllc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBEb3ROb3RhdGlvblV0aWwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNpbmcgZG90IG5vdGF0aW9uLCBpdGVyYXRlIHRoZSBvYmplY3QgYW5kIGNoYW5nZSB0aGUga2V5J3MgdmFsdWVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqIG9iamVjdCB0byB0ZXN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb3BlcnR5UGF0aCBEb3Qgbm90YXRpb24gcGF0aFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuZXdWYWwgQ2hhbmdlZCB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFNldFZhbHVlKG9iajogSlNPTiB8IG9iamVjdCwgcHJvcGVydHlQYXRoOiBzdHJpbmcsIG5ld1ZhbDogc3RyaW5nIHwgb2JqZWN0IHwgQXJyYXk8YW55Pik6IHZvaWQge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNwbGl0IHByb3BlcnR5UGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBpdGVyYXRlIGVhY2ggaXRtIHdpdGggcmVkdWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYWNjKGFjY3VtdWxhdG9yKSByZXR1cm5lZCBvYmplY3QgdG8gaXRlcmF0ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGN1cnIoY3VycmVudCB2YWx1ZSkgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggaW5kZXggcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYXJyIGFycmF5IHdlIGNyZWF0ZWQgd2l0aCB0aGUgc3BsaXQgZnVuY3Rpb24gYWJvdmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoIChhY2MsIGN1cnIsIGlkeCwgYXJyKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIGlkeCA9PT0gKGFyci5sZW5ndGggLSAxKSAmJiBhY2MgKSB7XHJcbiAgICAgICAgICAgIGFjY1tjdXJyXSA9IG5ld1ZhbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIHJldHVybiBhIG5ldyBhY2N1bXVsYXRvciB0byB0aGUgcmVkdWNlIGNhbGxiYWNrKHN0YXJ0cyB0aGUgbG9vcCB3aXRoIHRoZSBuZXh0IGN1cnIgdmFsdWUpXHJcbiAgICAgICAgICByZXR1cm4gYWNjID8gYWNjW2N1cnJdIDogbnVsbDtcclxuXHJcbiAgICAgICAgLy8gaW5pdGFsIHZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQodGhpcyBpcyB0aGUgaXRlbSB0byBzdGFydCB0aGUgaXRlcmF0aW9uIHdpdGgpXHJcbiAgICAgIH0sIG9iaik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBkb3Qgbm90YXRpb24sIGl0ZXJhdGUgdGhlIG9iamVjdCBhbmQgcmV0dXJuIHRoZSBrZXkncyB2YWx1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmogb2JqZWN0IHRvIHRlc3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aEFyciBhcnJheSBvZiBuYW1lcyB1c2VkIHRvIGRyaWxsIGludG8gb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldFZhbHVlKG9iajogSlNPTiB8IG9iamVjdCwgcHJvcGVydHlQYXRoOiBzdHJpbmcpOiBzdHJpbmcgfCBvYmplY3QgfCBBcnJheTxhbnk+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzcGxpdCBwcm9wZXJ0eVBhdGggc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgaXRlcmF0ZSBlYWNoIGl0bSB3aXRoIHJlZHVjZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFjYyhhY2N1bXVsYXRvcikgcmV0dXJuZWQgb2JqZWN0IHRvIGl0ZXJhdGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBjdXJyKGN1cnJlbnQgdmFsdWUpIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gaWR4IGluZGV4IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBhcnJheVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGFyciBhcnJheSB3ZSBjcmVhdGVkIHdpdGggdGhlIHNwbGl0IGZ1bmN0aW9uIGFib3ZlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgcmV0dXJuIHByb3BlcnR5UGF0aC5zcGxpdCgnLicpLnJlZHVjZSggKGFjYywgY3VyciwgaWR4LCBhcnIpID0+IHtcclxuICAgICAgICBpZiAoIGlkeCA9PT0gKGFyci5sZW5ndGggLSAxKSAmJiBhY2MgKSB7XHJcbiAgICAgICAgICByZXR1cm4gYWNjW2N1cnJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXR1cm4gYSBuZXcgYWNjdW11bGF0b3IgdG8gdGhlIHJlZHVjZSBjYWxsYmFjayhzdGFydHMgdGhlIGxvb3Agd2l0aCB0aGUgbmV4dCBjdXJyIHZhbHVlKVxyXG4gICAgICAgIHJldHVybiBhY2MgPyBhY2NbY3Vycl0gOiBudWxsO1xyXG5cclxuICAgICAgLy8gaW5pdGFsIHZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQodGhpcyBpcyB0aGUgaXRlbSB0byBzdGFydCB0aGUgaXRlcmF0aW9uIHdpdGgpXHJcbiAgICB9LCBvYmopO1xyXG4gIH1cclxuICBwdWJsaWMgc3RhdGljIFNldEtleVZhbHVlKGpzb246IEpTT04gfCBKU09OU2NoZW1hLCBwcm9wZXJ0eVBhdGg6IHN0cmluZywgb2xkS2V5OiBzdHJpbmcsIG5ld0tleTogc3RyaW5nLCBvYmpUb0NoYW5nZTogc3RyaW5nKTogYW55IHtcclxuXHJcbiAgICAvLyBmb3IgdG9wIGxldmVsIHByb3BlcnRpZXNcclxuICAgIGlmIChwcm9wZXJ0eVBhdGguc3BsaXQoJy4nKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGpzb24pLnJlZHVjZSggKGFjYywgY3VyciwgaWR4LCBhcnIpID0+XHJcbiAgICAgICAgY3VyciA9PT0gb2xkS2V5ID8gKHsgLi4uYWNjLCBbbmV3S2V5XToganNvbltvbGRLZXldIH0pIDogKHsuLi5hY2MsIFtjdXJyXToganNvbltjdXJyXX0pLCB7fSApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZvciBuZXN0ZWQgcHJvcGVydGllc1xyXG4gICAgaWYgKHByb3BlcnR5UGF0aC5zcGxpdCgnLicpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgcmV0dXJuIHByb3BlcnR5UGF0aC5zcGxpdCgnLicpLnJlZHVjZSggKGFjYywgY3VyciwgaWR4LCBhcnIpID0+IHtcclxuICAgICAgICAgIGlmICggaWR4ID09PSAoYXJyLmxlbmd0aCAtIDEpICYmIGFjYyApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGlkeFBvczogbnVtYmVyID0gYXJyLmluZGV4T2Yob2JqVG9DaGFuZ2UpO1xyXG4gICAgICAgICAgICBjb25zdCBpZHhQb3NBcnI6IEFycmF5PHN0cmluZz4gPSBbIC4uLmFyci5zcGxpY2UoMCwgaWR4UG9zICsgMSkgXTtcclxuXHJcbiAgICAgICAgICAgIERvdE5vdGF0aW9uVXRpbC5TZXRWYWx1ZShqc29uLCBpZHhQb3NBcnIuam9pbignLicpLCB0aGlzLlJlbmFtZUtleXMoe1tvbGRLZXldOiBuZXdLZXl9LCBhY2MpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgICAgICAgICAvLyByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyAgIC4uLnNjaGVtYSwgW29ialRvQ2hhbmdlXTogdGhpcy5yZW5hbWVLZXlzKHtbb2xkS2V5XTogbmV3S2V5fSwgYWNjKVxyXG4gICAgICAgICAgICAvLyB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGFjYyA/IGFjY1tjdXJyXSA6IG51bGw7IC8vIGlmIGFjYywgdGhlbiBzdGFydCBhZGRpdGlvbmFsIGl0ZXJhdGlvbnMgd2l0aCBhY2NbY3Vycl1cclxuICAgICAgfSwganNvbik7IC8vIGZpcnN0IGl0ZW0gdG8gc3RhcnQgdGhlIGxvb3BcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmFtZSBwcm9wZXJ0eSBrZXlzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBSZW5hbWVLZXlzKGtleXNNYXA6IG9iamVjdCwgb2JqOiBKU09OIHwgb2JqZWN0KTogb2JqZWN0IHtcclxuICAgIHJldHVybiBPYmplY3RcclxuICAgICAgICAgICAgLmtleXMob2JqKVxyXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHJlbmFtZWRPYmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBba2V5c01hcFtrZXldIHx8IGtleV06IG9ialtrZXldXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLi4uYWNjLFxyXG4gICAgICAgICAgICAgICAgLi4ucmVuYW1lZE9iamVjdFxyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuICB9XHJcbn1cclxuIl19