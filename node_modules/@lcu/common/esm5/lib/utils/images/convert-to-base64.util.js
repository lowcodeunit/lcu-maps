// @dynamic
import { __values } from "tslib";
/**
 * @dynamic is used because this class contains static properties
 */
import { Base64Model } from '../../models/base64.model';
import { Subject } from 'rxjs';
var ConvertToBase64Util = /** @class */ (function () {
    function ConvertToBase64Util() {
    }
    /**
     *
     * @param event either type File or Blob
     *
     * Converts to Base64 and returns an observable of Base64Model
     */
    ConvertToBase64Util.GetBase64 = function (files) {
        var e_1, _a;
        var base64Observable = new Subject();
        var baseArray = [];
        var file;
        var _loop_1 = function () {
            var reader = new FileReader();
            // tslint:disable-next-line:no-shadowed-variable
            (function (file) {
                reader.onload = function () {
                    baseArray.push(new Base64Model(reader.result.toString(), file));
                    if (baseArray.length === files.length) {
                        base64Observable.next(baseArray);
                    }
                };
            })(file);
            reader.readAsDataURL(file['file'].rawFile);
            reader.onerror = function (error) {
                console.error('Error: ', error);
            };
        };
        try {
            for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                file = files_1_1.value;
                _loop_1();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return base64Observable;
    };
    return ConvertToBase64Util;
}());
export { ConvertToBase64Util };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC10by1iYXNlNjQudXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BsY3UvY29tbW9uLyIsInNvdXJjZXMiOlsibGliL3V0aWxzL2ltYWdlcy9jb252ZXJ0LXRvLWJhc2U2NC51dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFdBQVc7O0FBRVg7O0dBRUc7QUFFSCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEQsT0FBTyxFQUEwQixPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFdkQ7SUFBQTtJQWlDQSxDQUFDO0lBL0JHOzs7OztPQUtHO0lBQ1csNkJBQVMsR0FBdkIsVUFBd0IsS0FBa0I7O1FBQ3hDLElBQU0sZ0JBQWdCLEdBQUcsSUFBSSxPQUFPLEVBQXNCLENBQUM7UUFDM0QsSUFBTSxTQUFTLEdBQXVCLEVBQUUsQ0FBQztRQUN6QyxJQUFJLElBQVUsQ0FBQzs7WUFHYixJQUFNLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2hDLGdEQUFnRDtZQUNoRCxDQUFDLFVBQUMsSUFBSTtnQkFDTixNQUFNLENBQUMsTUFBTSxHQUFHO29CQUNkLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUVoRSxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssS0FBSyxDQUFDLE1BQU0sRUFBRTt3QkFDckMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUNsQztnQkFDSCxDQUFDLENBQUM7WUFDSixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNQLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBQyxLQUFLO2dCQUNyQixPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNsQyxDQUFDLENBQUM7OztZQWZKLEtBQWEsSUFBQSxVQUFBLFNBQUEsS0FBSyxDQUFBLDRCQUFBO2dCQUFiLElBQUksa0JBQUE7O2FBZ0JSOzs7Ozs7Ozs7UUFFRCxPQUFPLGdCQUFnQixDQUFDO0lBQzFCLENBQUM7SUFDTCwwQkFBQztBQUFELENBQUMsQUFqQ0QsSUFpQ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZHluYW1pY1xyXG5cclxuLyoqXHJcbiAqIEBkeW5hbWljIGlzIHVzZWQgYmVjYXVzZSB0aGlzIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQmFzZTY0TW9kZWwgfSBmcm9tICcuLi8uLi9tb2RlbHMvYmFzZTY0Lm1vZGVsJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaWJlciwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbnZlcnRUb0Jhc2U2NFV0aWwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudCBlaXRoZXIgdHlwZSBGaWxlIG9yIEJsb2JcclxuICAgICAqXHJcbiAgICAgKiBDb252ZXJ0cyB0byBCYXNlNjQgYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBCYXNlNjRNb2RlbFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIEdldEJhc2U2NChmaWxlczogQXJyYXk8RmlsZT4pOiBPYnNlcnZhYmxlPEFycmF5PEJhc2U2NE1vZGVsPj4ge1xyXG4gICAgICBjb25zdCBiYXNlNjRPYnNlcnZhYmxlID0gbmV3IFN1YmplY3Q8QXJyYXk8QmFzZTY0TW9kZWw+PigpO1xyXG4gICAgICBjb25zdCBiYXNlQXJyYXk6IEFycmF5PEJhc2U2NE1vZGVsPiA9IFtdO1xyXG4gICAgICBsZXQgZmlsZTogRmlsZTtcclxuXHJcbiAgICAgIGZvciAoZmlsZSBvZiBmaWxlcykge1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXNoYWRvd2VkLXZhcmlhYmxlXHJcbiAgICAgICAgKChmaWxlKSA9PiB7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIGJhc2VBcnJheS5wdXNoKG5ldyBCYXNlNjRNb2RlbChyZWFkZXIucmVzdWx0LnRvU3RyaW5nKCksIGZpbGUpKTtcclxuXHJcbiAgICAgICAgICBpZiAoYmFzZUFycmF5Lmxlbmd0aCA9PT0gZmlsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJhc2U2NE9ic2VydmFibGUubmV4dChiYXNlQXJyYXkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pKGZpbGUpO1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVbJ2ZpbGUnXS5yYXdGaWxlKTtcclxuICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6ICcsIGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYmFzZTY0T2JzZXJ2YWJsZTtcclxuICAgIH1cclxufVxyXG4iXX0=