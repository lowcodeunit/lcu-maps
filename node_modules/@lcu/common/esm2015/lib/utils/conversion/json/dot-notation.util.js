// @dynamic
/**
 * @dynamic is used because this class contains static properties
 */
export class DotNotationUtil {
    /**
     * Using dot notation, iterate the object and change the key's value
     *
     * @param obj object to test
     *
     * @param propertyPath Dot notation path
     *
     * @param newVal Changed value
     */
    static SetValue(obj, propertyPath, newVal) {
        /**
         * split propertyPath string into an array of strings and iterate each itm with reduce
         *
         * @param acc(accumulator) returned object to iterate
         *
         * @param curr(current value) current element being processed in the array
         *
         * @param idx index position of the current element being processed in the array
         *
         * @param arr array we created with the split function above
         *
         */
        return propertyPath.split('.').reduce((acc, curr, idx, arr) => {
            if (idx === (arr.length - 1) && acc) {
                acc[curr] = newVal;
            }
            // return a new accumulator to the reduce callback(starts the loop with the next curr value)
            return acc ? acc[curr] : null;
            // inital value to use as the first argument(this is the item to start the iteration with)
        }, obj);
    }
    /**
     * Using dot notation, iterate the object and return the key's value
     *
     * @param obj object to test
     *
     * @param pathArr array of names used to drill into objects
     */
    static GetValue(obj, propertyPath) {
        /**
         * split propertyPath string into an array of strings and iterate each itm with reduce
         *
         * @param acc(accumulator) returned object to iterate
         *
         * @param curr(current value) current element being processed in the array
         *
         * @param idx index position of the current element being processed in the array
         *
         * @param arr array we created with the split function above
         *
         */
        return propertyPath.split('.').reduce((acc, curr, idx, arr) => {
            if (idx === (arr.length - 1) && acc) {
                return acc[curr];
            }
            // return a new accumulator to the reduce callback(starts the loop with the next curr value)
            return acc ? acc[curr] : null;
            // inital value to use as the first argument(this is the item to start the iteration with)
        }, obj);
    }
    static SetKeyValue(json, propertyPath, oldKey, newKey, objToChange) {
        // for top level properties
        if (propertyPath.split('.').length === 1) {
            return Object.keys(json).reduce((acc, curr, idx, arr) => curr === oldKey ? (Object.assign(Object.assign({}, acc), { [newKey]: json[oldKey] })) : (Object.assign(Object.assign({}, acc), { [curr]: json[curr] })), {});
        }
        // for nested properties
        if (propertyPath.split('.').length > 1) {
            return propertyPath.split('.').reduce((acc, curr, idx, arr) => {
                if (idx === (arr.length - 1) && acc) {
                    const idxPos = arr.indexOf(objToChange);
                    const idxPosArr = [...arr.splice(0, idxPos + 1)];
                    DotNotationUtil.SetValue(json, idxPosArr.join('.'), this.RenameKeys({ [oldKey]: newKey }, acc));
                    return json;
                    // return {
                    //   ...schema, [objToChange]: this.renameKeys({[oldKey]: newKey}, acc)
                    // };
                }
                return acc ? acc[curr] : null; // if acc, then start additional iterations with acc[curr]
            }, json); // first item to start the loop
        }
    }
    /**
     * Rename property keys
     */
    static RenameKeys(keysMap, obj) {
        return Object
            .keys(obj)
            .reduce((acc, key) => {
            const renamedObject = {
                [keysMap[key] || key]: obj[key]
            };
            return Object.assign(Object.assign({}, acc), renamedObject);
        }, {});
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90LW5vdGF0aW9uLnV0aWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbGN1L2NvbW1vbi8iLCJzb3VyY2VzIjpbImxpYi91dGlscy9jb252ZXJzaW9uL2pzb24vZG90LW5vdGF0aW9uLnV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsV0FBVztBQUVYOztHQUVHO0FBRUgsTUFBTSxPQUFPLGVBQWU7SUFFeEI7Ozs7Ozs7O09BUUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQWtCLEVBQUUsWUFBb0IsRUFBRSxNQUFvQztRQUNqRzs7Ozs7Ozs7Ozs7V0FXRztRQUNILE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUM3RCxJQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFHO2dCQUNyQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQ3BCO1lBQ0QsNEZBQTRGO1lBQzVGLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUVoQywwRkFBMEY7UUFDNUYsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBa0IsRUFBRSxZQUFvQjtRQUMzRDs7Ozs7Ozs7Ozs7V0FXRztRQUNMLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUM3RCxJQUFLLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElB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Li4vanNvbi1zY2hlbWEnO1xyXG4vLyBAZHluYW1pY1xyXG5cclxuLyoqXHJcbiAqIEBkeW5hbWljIGlzIHVzZWQgYmVjYXVzZSB0aGlzIGNsYXNzIGNvbnRhaW5zIHN0YXRpYyBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIERvdE5vdGF0aW9uVXRpbCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2luZyBkb3Qgbm90YXRpb24sIGl0ZXJhdGUgdGhlIG9iamVjdCBhbmQgY2hhbmdlIHRoZSBrZXkncyB2YWx1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmogb2JqZWN0IHRvIHRlc3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlQYXRoIERvdCBub3RhdGlvbiBwYXRoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld1ZhbCBDaGFuZ2VkIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgU2V0VmFsdWUob2JqOiBKU09OIHwgb2JqZWN0LCBwcm9wZXJ0eVBhdGg6IHN0cmluZywgbmV3VmFsOiBzdHJpbmcgfCBvYmplY3QgfCBBcnJheTxhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc3BsaXQgcHJvcGVydHlQYXRoIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIGl0ZXJhdGUgZWFjaCBpdG0gd2l0aCByZWR1Y2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhY2MoYWNjdW11bGF0b3IpIHJldHVybmVkIG9iamVjdCB0byBpdGVyYXRlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gY3VycihjdXJyZW50IHZhbHVlKSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBhcnJheVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGlkeCBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBhcnIgYXJyYXkgd2UgY3JlYXRlZCB3aXRoIHRoZSBzcGxpdCBmdW5jdGlvbiBhYm92ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5UGF0aC5zcGxpdCgnLicpLnJlZHVjZSggKGFjYywgY3VyciwgaWR4LCBhcnIpID0+IHtcclxuICAgICAgICAgIGlmICggaWR4ID09PSAoYXJyLmxlbmd0aCAtIDEpICYmIGFjYyApIHtcclxuICAgICAgICAgICAgYWNjW2N1cnJdID0gbmV3VmFsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGFjY3VtdWxhdG9yIHRvIHRoZSByZWR1Y2UgY2FsbGJhY2soc3RhcnRzIHRoZSBsb29wIHdpdGggdGhlIG5leHQgY3VyciB2YWx1ZSlcclxuICAgICAgICAgIHJldHVybiBhY2MgPyBhY2NbY3Vycl0gOiBudWxsO1xyXG5cclxuICAgICAgICAvLyBpbml0YWwgdmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCh0aGlzIGlzIHRoZSBpdGVtIHRvIHN0YXJ0IHRoZSBpdGVyYXRpb24gd2l0aClcclxuICAgICAgfSwgb2JqKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzaW5nIGRvdCBub3RhdGlvbiwgaXRlcmF0ZSB0aGUgb2JqZWN0IGFuZCByZXR1cm4gdGhlIGtleSdzIHZhbHVlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9iaiBvYmplY3QgdG8gdGVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoQXJyIGFycmF5IG9mIG5hbWVzIHVzZWQgdG8gZHJpbGwgaW50byBvYmplY3RzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgR2V0VmFsdWUob2JqOiBKU09OIHwgb2JqZWN0LCBwcm9wZXJ0eVBhdGg6IHN0cmluZyk6IHN0cmluZyB8IG9iamVjdCB8IEFycmF5PGFueT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNwbGl0IHByb3BlcnR5UGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBpdGVyYXRlIGVhY2ggaXRtIHdpdGggcmVkdWNlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYWNjKGFjY3VtdWxhdG9yKSByZXR1cm5lZCBvYmplY3QgdG8gaXRlcmF0ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIGN1cnIoY3VycmVudCB2YWx1ZSkgY3VycmVudCBlbGVtZW50IGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgYXJyYXlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBpZHggaW5kZXggcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgZWxlbWVudCBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gYXJyIGFycmF5IHdlIGNyZWF0ZWQgd2l0aCB0aGUgc3BsaXQgZnVuY3Rpb24gYWJvdmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICByZXR1cm4gcHJvcGVydHlQYXRoLnNwbGl0KCcuJykucmVkdWNlKCAoYWNjLCBjdXJyLCBpZHgsIGFycikgPT4ge1xyXG4gICAgICAgIGlmICggaWR4ID09PSAoYXJyLmxlbmd0aCAtIDEpICYmIGFjYyApIHtcclxuICAgICAgICAgIHJldHVybiBhY2NbY3Vycl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBhY2N1bXVsYXRvciB0byB0aGUgcmVkdWNlIGNhbGxiYWNrKHN0YXJ0cyB0aGUgbG9vcCB3aXRoIHRoZSBuZXh0IGN1cnIgdmFsdWUpXHJcbiAgICAgICAgcmV0dXJuIGFjYyA/IGFjY1tjdXJyXSA6IG51bGw7XHJcblxyXG4gICAgICAvLyBpbml0YWwgdmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCh0aGlzIGlzIHRoZSBpdGVtIHRvIHN0YXJ0IHRoZSBpdGVyYXRpb24gd2l0aClcclxuICAgIH0sIG9iaik7XHJcbiAgfVxyXG4gIHB1YmxpYyBzdGF0aWMgU2V0S2V5VmFsdWUoanNvbjogSlNPTiB8IEpTT05TY2hlbWEsIHByb3BlcnR5UGF0aDogc3RyaW5nLCBvbGRLZXk6IHN0cmluZywgbmV3S2V5OiBzdHJpbmcsIG9ialRvQ2hhbmdlOiBzdHJpbmcpOiBhbnkge1xyXG5cclxuICAgIC8vIGZvciB0b3AgbGV2ZWwgcHJvcGVydGllc1xyXG4gICAgaWYgKHByb3BlcnR5UGF0aC5zcGxpdCgnLicpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoanNvbikucmVkdWNlKCAoYWNjLCBjdXJyLCBpZHgsIGFycikgPT5cclxuICAgICAgICBjdXJyID09PSBvbGRLZXkgPyAoeyAuLi5hY2MsIFtuZXdLZXldOiBqc29uW29sZEtleV0gfSkgOiAoey4uLmFjYywgW2N1cnJdOiBqc29uW2N1cnJdfSksIHt9ICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIG5lc3RlZCBwcm9wZXJ0aWVzXHJcbiAgICBpZiAocHJvcGVydHlQYXRoLnNwbGl0KCcuJykubGVuZ3RoID4gMSkge1xyXG4gICAgICByZXR1cm4gcHJvcGVydHlQYXRoLnNwbGl0KCcuJykucmVkdWNlKCAoYWNjLCBjdXJyLCBpZHgsIGFycikgPT4ge1xyXG4gICAgICAgICAgaWYgKCBpZHggPT09IChhcnIubGVuZ3RoIC0gMSkgJiYgYWNjICkge1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaWR4UG9zOiBudW1iZXIgPSBhcnIuaW5kZXhPZihvYmpUb0NoYW5nZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeFBvc0FycjogQXJyYXk8c3RyaW5nPiA9IFsgLi4uYXJyLnNwbGljZSgwLCBpZHhQb3MgKyAxKSBdO1xyXG5cclxuICAgICAgICAgICAgRG90Tm90YXRpb25VdGlsLlNldFZhbHVlKGpzb24sIGlkeFBvc0Fyci5qb2luKCcuJyksIHRoaXMuUmVuYW1lS2V5cyh7W29sZEtleV06IG5ld0tleX0sIGFjYykpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGpzb247XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vICAgLi4uc2NoZW1hLCBbb2JqVG9DaGFuZ2VdOiB0aGlzLnJlbmFtZUtleXMoe1tvbGRLZXldOiBuZXdLZXl9LCBhY2MpXHJcbiAgICAgICAgICAgIC8vIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYWNjID8gYWNjW2N1cnJdIDogbnVsbDsgLy8gaWYgYWNjLCB0aGVuIHN0YXJ0IGFkZGl0aW9uYWwgaXRlcmF0aW9ucyB3aXRoIGFjY1tjdXJyXVxyXG4gICAgICB9LCBqc29uKTsgLy8gZmlyc3QgaXRlbSB0byBzdGFydCB0aGUgbG9vcFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVuYW1lIHByb3BlcnR5IGtleXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIFJlbmFtZUtleXMoa2V5c01hcDogb2JqZWN0LCBvYmo6IEpTT04gfCBvYmplY3QpOiBvYmplY3Qge1xyXG4gICAgcmV0dXJuIE9iamVjdFxyXG4gICAgICAgICAgICAua2V5cyhvYmopXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgcmVuYW1lZE9iamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIFtrZXlzTWFwW2tleV0gfHwga2V5XTogb2JqW2tleV1cclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5hY2MsXHJcbiAgICAgICAgICAgICAgICAuLi5yZW5hbWVkT2JqZWN0XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSwge30pO1xyXG4gIH1cclxufVxyXG4iXX0=