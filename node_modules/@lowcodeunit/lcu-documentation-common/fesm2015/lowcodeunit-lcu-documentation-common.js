import { ɵɵdefineInjectable, Injectable, EventEmitter, Component, Input, Output, HostListener, NgModule, ɵɵinject, INJECTOR, Injector } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FlexLayoutModule } from '@angular/flex-layout';
import { FathymSharedModule, MaterialModule, StateContext } from '@lcu/common';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { isString } from 'util';
import { FlatTreeControl } from '@angular/cdk/tree';
import { MatTreeFlattener, MatTreeFlatDataSource } from '@angular/material/tree';
import { of } from 'rxjs';
import { MarkedRenderer, MarkdownModule, MarkedOptions } from 'ngx-markdown';

class DocsService {
    constructor() { }
}
DocsService.ɵprov = ɵɵdefineInjectable({ factory: function DocsService_Factory() { return new DocsService(); }, token: DocsService, providedIn: "root" });
DocsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DocsService.ctorParameters = () => [];

class FileNode {
}
/** Flat node with expandable and level information */
class FileFlatNode {
    constructor(expandable, filename, level, path) {
        this.expandable = expandable;
        this.filename = filename;
        this.level = level;
        this.path = path;
    }
}
const originalHeading = new MarkedRenderer().heading;
function markedOptionsFactory() {
    const renderer = new MarkedRenderer();
    let lastLevel = 0;
    renderer.heading = (text, level, raw) => {
        lastLevel = level;
        return '<h' + level + '>' + text + '</h' + level + '>\n';
    };
    renderer.link = (href, title, text) => {
        return `<a title="${title || ''}" href="${href}">${text ||
            title ||
            href}</a>`;
    };
    renderer.paragraph = (text) => {
        let pClass = '';
        switch (lastLevel) {
            case 1:
            case 2:
                pClass = 'mat-body-3';
                break;
            case 3:
            case 4:
                pClass = 'mat-body-2';
                break;
            default:
                pClass = 'mat-body-1';
                break;
        }
        return `<p class="${pClass}">${text}</p>`;
    };
    return { renderer };
}
const path = require('path-browserify');
class LcuDocsComponent {
    //  Constructors
    constructor(http) {
        this.http = http;
        this.DocChange = new EventEmitter();
        this.TreeFlattener = new MatTreeFlattener(this.Transformer, this.getLevel, this.isExpandable, this.getChildren);
        this.TreeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.DataSource = new MatTreeFlatDataSource(this.TreeControl, this.TreeFlattener);
    }
    set Docs(docs) {
        this.http
            .get(path.join(docs, 'lcu.docs.json'))
            .subscribe((res) => {
            this.Config = res;
            this.Reload();
        });
    }
    //  Life Cycle
    ngOnInit() {
        this.Reload();
    }
    onClick(btn) {
        if (btn && btn.href && btn.href.endsWith('.md')) {
            const path = btn.href.replace(document.getElementsByTagName('base')[0].href, '');
            console.log(`Going to doc: ${path}`);
            this.GoToDoc(path);
            return false;
        }
    }
    //  API Methods
    BuildFileTree() {
        this.DataSource.data = this.buildFileTree(this.Config.Docs, 0);
    }
    FindDoc(path) {
        return this.Config.Docs.find(d => d.Path === path);
    }
    GoToDoc(docOpt) {
        const docPath = isString(docOpt)
            ? docOpt
            : docOpt.Path;
        if (this.ActiveDocPath !== docPath) {
            this.ActiveDocPath = docPath;
        }
        this.calculateActiveDocData();
        this.DocChange.emit({ DocPath: docPath });
    }
    HasChild(_, nodeData) {
        return nodeData.expandable;
    }
    Reload() {
        if (this.Config && this.Config.Docs && this.Config.Docs.length > 0) {
            this.BuildFileTree();
            this.GoToDoc(this.ActiveDocPath || this.Config.DefaultDocPath || this.Config.Docs[0]);
        }
    }
    Transformer(node) {
        return new FileFlatNode(!!node.children, node.filename, node.level, node.path);
    }
    //  Helpers
    buildFileTree(docs, level) {
        return docs.reduce((accumulator, doc) => {
            const node = this.buildFileNodeFromDoc(doc, level);
            return accumulator.concat(node);
        }, []);
    }
    buildFileNodeFromDoc(doc, level, bypassChildren) {
        const node = new FileNode();
        if (doc != null) {
            node.filename = doc.Title;
            node.level = level;
            if (!bypassChildren && doc.Children && doc.Children.length > 0) {
                node.children = this.buildFileTree(doc.Children, level + 1);
                const docCatch = Object.assign({}, doc);
                docCatch.Children = null;
            }
            else {
                node.path = doc.Path;
            }
        }
        return node;
    }
    calculateActiveDocData() {
        if (this.Config && this.ActiveDocPath) {
            this.ActiveDocData = path.join(this.Config.LocationRoot, this.ActiveDocPath);
        }
        else {
            this.ActiveDocData = null;
        }
    }
    getLevel(node) {
        return node.level;
    }
    isExpandable(node) {
        return node.expandable;
    }
    getChildren(node) {
        return of(node.children);
    }
}
LcuDocsComponent.decorators = [
    { type: Component, args: [{
                selector: 'lcu-markdown-docs',
                template: "<div fxLayout=\"row\" *ngIf=\"Config\">\r\n  <div fxFlex=\"0 1 auto\">\r\n    <mat-tree [dataSource]=\"DataSource\" [treeControl]=\"TreeControl\">\r\n      <mat-tree-node\r\n        *matTreeNodeDef=\"let node\"\r\n        matTreeNodeToggle\r\n        [matTreeNodePadding]=\"Config.IndentVariant * node.level\"\r\n      >\r\n        <button mat-icon-button disabled></button>\r\n\r\n        <a mat-button (click)=\"GoToDoc(node.path)\">{{ node.filename }}</a>\r\n      </mat-tree-node>\r\n\r\n      <mat-tree-node\r\n        *matTreeNodeDef=\"let node; when: HasChild\"\r\n        [matTreeNodePadding]=\"Config.IndentVariant * node.level\"\r\n      >\r\n        <button\r\n          mat-icon-button\r\n          matTreeNodeToggle\r\n          [attr.aria-label]=\"'toggle ' + node.filename\"\r\n        >\r\n          <mat-icon class=\"mat-icon-rtl-mirror\">\r\n            {{ TreeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\r\n          </mat-icon>\r\n        </button>\r\n\r\n        <a mat-button matTreeNodeToggle>{{ node.filename }}</a>\r\n      </mat-tree-node>\r\n    </mat-tree>\r\n  </div>\r\n\r\n  <div fxFlex=\"auto\">\r\n    <div class=\"push-right\">\r\n      <ng-container *ngIf=\"!!ActiveDocData\">\r\n        <markdown [src]=\"ActiveDocData\"></markdown>\r\n      </ng-container>\r\n    </div>\r\n  </div>\r\n</div>\r\n",
                styles: [":host .mat-tree{padding:1rem}"]
            },] }
];
LcuDocsComponent.ctorParameters = () => [
    { type: HttpClient }
];
LcuDocsComponent.propDecorators = {
    Config: [{ type: Input, args: ['config',] }],
    Docs: [{ type: Input, args: ['docs',] }],
    DocChange: [{ type: Output, args: ['docChange',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event.target'],] }]
};

const ɵ0 = markedOptionsFactory;
class LcuDocumentationModule {
    static forRoot() {
        return {
            ngModule: LcuDocumentationModule,
            providers: [DocsService]
        };
    }
}
LcuDocumentationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [LcuDocsComponent],
                imports: [
                    FathymSharedModule,
                    FormsModule,
                    ReactiveFormsModule,
                    FlexLayoutModule,
                    MaterialModule,
                    HttpClientModule,
                    MarkdownModule.forRoot({
                        loader: HttpClient,
                        markedOptions: {
                            provide: MarkedOptions,
                            useFactory: ɵ0
                        }
                    })
                ],
                exports: [LcuDocsComponent],
                entryComponents: []
            },] }
];

class LcuMarkdownDocsConfig {
    constructor(opts) {
        Object.assign(this, opts);
    }
}
class LcuMarkdownDoc {
    constructor(opts) {
        Object.assign(this, opts);
    }
}
class LcuMarkdownDocChangeEvent {
    constructor(opts) {
        Object.assign(this, opts);
    }
}

class DocsModel {
}

class DocsManagerContext extends StateContext {
    constructor(injector) {
        super(injector);
        this.injector = injector;
    }
    GetDocsById(id) {
        this.State.Loading = true;
        this.Execute({
            Arguments: {
                DocsId: id
            },
            Type: 'get-docs-by-id'
        });
    }
    loadStateKey() {
        return 'main';
    }
    loadStateName() {
        return 'docs';
    }
}
DocsManagerContext.ɵprov = ɵɵdefineInjectable({ factory: function DocsManagerContext_Factory() { return new DocsManagerContext(ɵɵinject(INJECTOR)); }, token: DocsManagerContext, providedIn: "root" });
DocsManagerContext.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DocsManagerContext.ctorParameters = () => [
    { type: Injector }
];

class DocsUtils {
    static upperDocs(input) {
        return input.toUpperCase();
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { DocsManagerContext, DocsModel, DocsService, DocsUtils, FileFlatNode, FileNode, LcuDocsComponent, LcuDocumentationModule, LcuMarkdownDoc, LcuMarkdownDocChangeEvent, LcuMarkdownDocsConfig, markedOptionsFactory, originalHeading, ɵ0 };
//# sourceMappingURL=lowcodeunit-lcu-documentation-common.js.map
